  ${
    $d n p N $.  $d n x N $.
    $( Bertrand's postulate: there is a prime between ` N ` and ` 2 N ` for
       every positive integer ` N ` .  This proof follows Erd&#337;s's method,
       for the most part, but with some refinements due to Shigenori Tochiori
       to save us some calculations of large primes.  See
       ~ http://en.wikipedia.org/wiki/Proof_of_Bertrand%27s_postulate for an
       overview of the proof strategy. $)
    bpos $p |- ( N e. NN -> E. p e. Prime ( N < p /\ p <_ ( 2 x. N ) ) ) $=
      ( vx vn cn wcel c2 c6 co cle wbr clt cv cmul wa cr csqr cfv clog cdiv cn0
      cexp cprime wrex nnre 2re 6nn nnnn0i reexpcl mp2an lelttric sylancl bpos1
      wo wn crp cmpt c9 c4 caddc simpll simplr simpr bposlem7 ex pm2.18d jaodan
      eqid mpdan ) AEFZAGHUBIZJKZVKALKZUNZABMZLKVOGANIJKOBUCUDZVJAPFVKPFZVNAUEG
      PFHUAFVQUFHUGUHGHUIUJAVKUKULVJVLVPVMABUMVJVMOZVPVRVPUOZVPVRVSOVPCDDEGQRDM
      ZQRCUPCMZSRWATIUQZRNIURUSTIVTGTIWBRNIUTIGSRGVTNIQRTIUTIUQZWBABWCVHWBVHVJV
      MVSVAVJVMVSVBVRVSVCVDVEVFVGVI $.
      $( [14-Mar-2014] $)
  $}
$(
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                             Godel-sets of formulas
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
$)

  $( Introduce new constant symbols. $)
  $c =g $. $( Godel-set of equality $)
  $c e.g $. $( Godel-set of membership $)
  $c /\g $. $( Godel-set of conjunction $)
  $c -.g $. $( Godel-set of negation $)
  $c A.g $. $( Godel-set of universal quantification $)
  $c ->g $. $( Godel-set of implication $)
  $c <->g $. $( Godel-set of equivalence $)
  $c \/g $. $( Godel-set of disjunction $)
  $c E.g $. $( Godel-set of existential quantification $)
  $c Fmla $. $( Formula predicate $)
  $c Sat $. $( Satisfaction predicate $)
  $c SatE $. $( Satisfaction predicate $)
  $c |= $. $( Proves relation $)

  $( The formula set predicate. $)
  cfmla $a class Fmla $.

  $( The satisfaction function. $)
  csat $a class Sat $.

  $( The ` e. ` -satisfaction function. $)
  csate $a class SatE $.

  $( The Godel-set of equality. $)
  cgoq $a class =g $.

  $( The Godel-set of membership. $)
  cgoe $a class e.g $.

  $( The Godel-set of conjunction. $)
  cgoa $a class /\g $.

  $( The Godel-set of negation.  (Note that this is not a wff.) $)
  cgon $a class -.g U $.

  $( The Godel-set of universal quantification.  (Note that this is not a
     wff.) $)
  cgol $a class A.g N U $.

  $( The "proves" relation. $)
  cprv $a class |= $.

  $( Define the Godel-set of equality.  Here the arguments ` x = <. N , P >. `
     correspond to v_N and v_P , so ` ( (/) =g 1o ) ` actually means v_0 ` = `
     v_1 , not ` 0 = 1 ` .  The reason we use ` ( N =g P ) ` and not ` N =g P `
     as the class expression is to maintain unambiguity: if ` N =g P ` was a
     class expression, then ` M =g N =g P ` would be ambiguous. $)
  df-goeq $a |- =g = ( x e. ( om X. om ) |-> <. (/) , x >. ) $.

  $( Define the Godel-set of membership.  Here the arguments
     ` x = <. N , P >. ` correspond to v_N and v_P , so ` ( (/) e.g 1o ) `
     actually means v_0 ` e. ` v_1 , not ` 0 e. 1 ` . $)
  df-goel $a |- e.g = ( x e. ( om X. om ) |-> <. 1o , x >. ) $.

  $( Define the Godel-set of conjunction.  Here the arguments
     ` x = <. U , V >. ` are also Godel-sets corresponding to smaller
     formulae. $)
  df-goan $a |- /\g = ( x e. ( _V X. _V ) |-> <. 2o , x >. ) $.

  $( Define the Godel-set of negation.  Here the argument ` U ` is also a
     Godel-set corresponding to smaller formulae.  Note that this is a _class_
     expression, not a wff. $)
  df-gonot $a |- -.g U = <. 3o , U >. $.

  $( Define the Godel-set of universal quantification.  Here ` N e. om `
     corresponds to v_N , and ` U ` represents another formula, and this
     expression is ` [ A. x ph ] = A.g N U ` where ` x ` is the ` N ` -th
     variable, ` U = [ ph ] ` is the code for ` ph ` .  Note that this is a
     _class_ expression, not a wff. $)
  df-goal $a |- A.g N U = <. 4o , <. N , U >. >. $.

  ${
    $d a e i j m u v x y z $.
    df-sat.eq $e |- ( ph <->
      ( x = ( i =g j ) /\
        y = { a e. ( m ^m om ) | ( a ` i ) = ( a ` j ) } ) ) $.
    df-sat.el $e |- ( ps <->
      ( x = ( i e.g j ) /\
        y = { a e. ( m ^m om ) | ( a ` i ) e ( a ` j ) } ) ) $.
    df-sat.an $e |- ( ch <-> E. v e. f
      ( x = ( ( 1st ` u ) /\g ( 1st ` v ) ) /\
        y = ( ( 2nd ` u ) i^i ( 2nd ` v ) ) ) ) $.
    df-sat.not $e |- ( th <->
      ( x = -.g ( 1st ` u ) /\ y = ( ( m ^m om ) \ ( 2nd ` u ) ) ) ) $.
    df-sat.al $e |- ( ta <-> E. i e. om
      ( x = A.g i ( 1st ` u ) /\
        y = { a e. ( m ^m om ) | A. z e. m ( { <. i , z >. } u.
          ( a |` ( om \ { i } ) ) ) e. ( 2nd ` u ) } ) ) $.
    $( Define the satisfaction predicate. This recursive construction builds up
       a function over wff codes and simultaneously defines the set of
       assignments to all variables from ` M ` that makes the coded wff true in
       the model ` M ` , where ` e. ` is interpreted as the binary relation ` E
       ` on ` M ` .

       The interpretation of the statement ` S e. ( ( ( M Sat E ) `` n ) `` U )
       ` is that for the model ` <. M , E >. ` , ` S : om --> M ` is an
       valuation of the variables (v_0 ` = ( S `` (/) ) ` , v_1 ` = ( S `` 1o
       ) ` , etc.) and ` U ` is a code for a wff using ` = , e. , \/ , -. , A.
       ` that is true under the assignment ` S ` . The function is defined by
       finite recursion; ` ( ( M Sat E ) `` n ) ` only operates on wffs of
       depth at most ` n e. om ` , and ` ( ( M Sat E ) `` om ) = U_ n e. om ( (
       M Sat E ) `` n ) ` operates on all wffs.

       The coding scheme for the wffs is defined so that <HTML><ul>
       <li>v<sub>i</sub> ` = ` v<sub>j</sub> is coded as
       ` <. (/) , <. i , j >. >. ` ,</li>
       <li>v<sub>i</sub> ` e. ` v<sub>j</sub> is coded as
       ` <. 1o , <. i , j >. >. ` ,</li>
       <li> ` ( ph /\ ps ) ` is coded as ` <. 2o , <. ph , ps >. >. ` ,</li>
       <li> ` -. ph ` is coded as ` <. 3o , ph >. ` , and</li>
       <li> ` A. ` v<sub>i</sub> ` ph ` is coded as
       ` <. 4o , <. i , ph >. >. ` .</li></ul></HTML>

       The pieces of the definition for these five types of wff have been split
       up into hypotheses for readability.
       $)
    df-sat $a |- Sat = ( m e. _V , e e. _V |->
       ( rec ( ( f e. _V |-> ( f u.
           { <. x , y >. | E. u e. f ( ch \/ th \/ ta ) } ) ) ,
           { <. x , y >. | E. i e. om E. j e. om ( ph \/ ps ) } )
         |` suc om ) ) $.
  $}

  ${
    $( A simplified version of the satisfaction predicate, using the standard
       membership relation and eliminating the extra variable ` n ` . $)
    df-sate $a |- SatE = ( m e. _V , u e. _V |->
       ( ( ( m Sat ( _E i^i ( m X. m ) ) ) ` om ) ` u ) ) $.
  $}

  $( Define the predicate which defines the set of valid Godel formulas.  The
     parameter ` n ` defines the maximum height of the formulas: the set
     ` ( Fmla `` (/) ) ` is all formulas of the form ` x = y ` or ` x e. y `
     (which in our coding scheme is the set
     ` ( { (/) , 1o } X. ( om X. om ) ) ` ; see ~ df-sat for the full coding
     scheme), and each extra level adds to the complexity of the formulas in
     ` ( Fmla `` n ) ` . ` ( Fmla `` om ) = U_ n e. om ( Fmla `` n ) ` is the
     set of all valid formulas. $)
  df-fmla $a |- Fmla = ( n e. suc om |-> dom ( ( (/) Sat (/) ) ` n ) ) $.

  $( The Godel-set of implication. $)
  cgoi $a class ->g $.

  $( The Godel-set of disjunction. $)
  cgoo $a class \/g $.

  $( The Godel-set of equivalence. $)
  cgob $a class <->g $.

  $( The Godel-set of existential quantification.  (Note that this is not a
     wff.) $)
  cgox $a class E.g N U $.

  $( Define the Godel-set of implication.  Here the arguments ` U ` and ` V `
     are also Godel-sets corresponding to smaller formulae.  Note that this is
     a _class_ expression, not a wff. $)
  df-goim $a |- ->g = ( u e. _V , v e. _V |-> -.g ( u /\g -.g v ) ) $.

  $( Define the Godel-set of disjunction.  Here the arguments ` U ` and ` V `
     are also Godel-sets corresponding to smaller formulae.  Note that this is
     a _class_ expression, not a wff. $)
  df-goor $a |- \/g = ( u e. _V , v e. _V |-> ( -.g u ->g v ) ) $.

  $( Define the Godel-set of equivalence.  Here the arguments ` U ` and ` V `
     are also Godel-sets corresponding to smaller formulae.  Note that this is
     a _class_ expression, not a wff. $)
  df-gobi $a |- <->g = ( u e. _V , v e. _V |->
                         ( ( u ->g v ) /\g ( v ->g u ) ) ) $.

  $( Define the Godel-set of existential quantification.  Here ` N e. om `
     corresponds to v_N , and ` U ` represents another formula, and this
     expression is ` [ E. x ph ] = E.g N U ` where ` x ` is the ` N ` -th
     variable, ` U = [ ph ] ` is the code for ` ph ` .  Note that this is a
     _class_ expression, not a wff. $)
  df-goex $a |- E.g N U = -.g A.g N -.g U $.

  $( Define the "proves" relation on a set.  A wff is true in a model ` M ` if
     for every valuation ` s e. ( M ^m om ) ` , the interpretation of the wff
     using the membership relation on ` M ` is true. $)
  df-prv $a |- |= = { <. m , u >. | ( m SatE u ) = ( m ^m om ) } $.

