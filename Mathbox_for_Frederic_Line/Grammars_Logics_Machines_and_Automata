$(
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
       Grammars, Logics, Machines and Automata
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
$)


  $c kleene $.

  $( Extend class notation with the kleene star. $)
  ckln $a class kleene $.

  ${
    $d x y a b u $.
    $( The Kleene star of a set ` x ` is the set of all the finite sequences of
       elements of this set.  Experimental. $)
    df-kle $a |- kleene = { <. x , y >. |
       y = { <. a , b >. | E. u e. NN0 ( a = ( 1 ... u ) /\ b : a --> x ) } }
        $.
  $}

  $c Grammar $.

  $( Extend class notation with the class of all the grammars. $)
  cgrm $a class Grammar $.

  ${
    $d x n t p s l r a $.
    $( A grammar is a structure composed of a set of non-terminal symbols
       ` n ` , of terminal symbols ` t ` , a set of productions ` p ` and a
       distinguished element of ` n ` , the start symbol ` s ` .
       Experimental. $)
    df-grm $a |- Grammar = { x | E. n E. t E. p E. s (
      x = <. <. n , t >. , <. p , s >. >. /\
      ( n e. Fin /\ t e. Fin /\ ( n i^i t ) = (/) ) /\
      p = { <. l , r >. |
        ( l e. ( kleene ` ( n u. t ) ) /\ r e. ( kleene ` ( n u. t ) )
          /\ E. a e. NN ( l ` a ) e. n ) } /\ s e. n ) } $.
  $}

  $c sym $.

  $( Extend class notation with a function returning the symbols of a
     grammar. $)
  csym $a class sym $.

  $( The symbols of a grammar ` g ` .  Experimental. $)
  df-sym $a |- sym = ( g e. Grammar |-> ( ( ( 1st o. 1st ) ` g ) u. (
    ( 2nd o. 1st ) ` g ) ) ) $.

  $c prdct $.

  $( Extend class notation with a function returning the productions of a
     grammar. $)
  cprdct $a class prdct $.

  $( The productions of a grammar. $)
  df-prodct $a |- prdct = ( 1st o. 2nd ) $.

  $c conc $.

  $( Extend class notation with an operation concatenating two sequences of
     symbols. $)
  cconc $a class conc $.

  ${
    $d x g y a b $.
    $( Concatenations of two sequences of symbols.  Experimental. $)
    df-conc $a |- conc = ( g e. Grammar |-> ( x e. ( kleene ` ( sym ` g ) ) , y
      e. ( kleene ` ( sym ` g ) ) |-> ( x u. { <. a , b >. | ( a e. ( (
      ( # ` x ) + 1 ) ... ( ( # ` x ) + ( # ` y ) ) ) /\ b = ( y ` ( a -
      ( # ` x ) ) ) ) } ) ) ) $.
  $}

  $c derv $.

  $( Extend class notation with the relation "derives in one step". $)
  cderv $a class derv $.

  ${
    $d g x y u v p q $.
    $( The relation ` u ` derives ` v ` in one step in the grammar ` g ` .
       Experimental. $)
    df-derv $a |- derv = ( g e. Grammar |-> { <. x , y >. | ( x e. (
     kleene ` g ) /\ y e. ( kleene ` g ) /\ E. u e. ( kleene ` g ) E. v
     e. ( kleene ` g ) E. p e. ( kleene ` g ) E. q e. ( kleene ` g ) ( x =
     ( ( u ( conc ` g ) p ) ( conc ` g ) v ) /\ <. p , q >. e. (
     prdct ` g ) /\ y = ( ( u ( conc ` g ) q ) ( conc ` g ) v ) ) ) }
     ) $.
  $}


$( (End of FL's mathbox.) $)


