$(
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
       Grammars, Logics, Machines and Automata
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
$)


  $c Kleene $.

  $( Extend class notation with the kleene star. $)
  ckln $a class Kleene $.

  $c Words $.

  $( Extend class notation with the class of words of a given size. $)
  cwrd $a class Words $.

  ${
    $d x y $.
    $( The words of size ` y ` over an alphabet ` x ` are the finite sequences
       over ` x ` of size ` y ` .  Their domains are fiercely set to
       ` ( 1 ... y ) ` so that I can concatenate them easily.  The case
       ` y = 0 ` is a bit tricky and corresponds to the unique empty word
       (often denoted by an epsilon or by ` 1 ` in textbooks.)
       Experimental. $)
    df-words $a |- Words = ( x e. _V , y e. NN0 |-> ( x ^m ( 1 ... y ) ) ) $.
  $}

  ${
    $d x y a u $.
    $( The Kleene star of an alphabet ` x ` is the set of all the finite
       sequences of elements of this alphabet.  Experimental. $)
    df-kle $a |- Kleene = { <. x , y >. |
       y = U. { a | E. u e. NN0 a = ( x ^m ( 1 ... u ) ) } } $.
  $}

  $c Grammar $.

  $( Extend class notation with the class of all grammars. $)
  cgrm $a class Grammar $.

  ${
    $d x n t p s l r a $.
    $( A grammar is a structure composed of a set of non-terminal symbols
       ` n ` , of terminal symbols ` t ` , a set of productions ` p ` and a
       distinguished element of ` n ` , the start symbol ` s ` .
       Experimental. $)
    df-grm $a |- Grammar = { x | E. n E. t E. p E. s (
      x = <. <. n , t >. , <. p , s >. >.
      /\ ( n e. Fin /\ t e. Fin /\ ( n i^i t ) = (/) )
      /\ ( p = { <. l , r >. |
        ( l e. ( Kleene ` ( n u. t ) ) /\ r e. ( Kleene ` ( n u. t ) )
          /\ E. a e. NN ( l ` a ) e. n ) }
        /\ s e. n ) ) } $.
  $}

  $c sym $.

  $( Extend class notation with a function returning the symbols of a
     grammar. $)
  csym $a class sym $.

  $( The symbols of a grammar ` g ` .  Experimental. $)
  df-sym $a |- sym = ( g e. Grammar |-> ( ( ( 1st o. 1st ) ` g ) u. (
    ( 2nd o. 1st ) ` g ) ) ) $.

  $c prdct $.

  $( Extend class notation with a function returning the productions of a
     grammar. $)
  cprdct $a class prdct $.

  $( The productions of a grammar. $)
  df-prodct $a |- prdct = ( 1st o. 2nd ) $.

  $c conc $.

  $( Extend class notation with an operation concatenating two sequences of
     symbols. $)
  cconc $a class conc $.

  ${
    $d x g y a b $.
    $( Concatenation of two words.  Experimental. $)
    df-conc $a |- conc = ( x e. _V , y e. _V |->
      ( x u. { <. a , b >. | ( a e. ( ( ( # ` x ) + 1 ) ... ( ( # ` x )
        + ( # ` y ) ) ) /\ b = ( y ` ( a - ( # ` x ) ) ) ) } ) ) $.
  $}

  $c derv $.

  $( Extend class notation with the relation "derives in one step". $)
  cderv $a class derv $.

  ${
    $d g x y u v p q $.
    $( The relation ` u ` derives ` v ` in one step in the grammar ` g ` .
       Experimental. $)
    df-derv $a |- derv = ( g e. Grammar |-> { <. x , y >. | ( x e. (
     Kleene ` g ) /\ y e. ( Kleene ` g ) /\ E. u e. ( Kleene ` g ) E. v
     e. ( Kleene ` g ) E. p e. ( Kleene ` g ) E. q e. ( Kleene ` g ) ( x =
     ( ( u ( conc ` g ) p ) ( conc ` g ) v ) /\ <. p , q >. e. (
     prdct ` g ) /\ y = ( ( u ( conc ` g ) q ) ( conc ` g ) v ) ) ) }
     ) $.
  $}


$( (End of FL's mathbox.) $)


