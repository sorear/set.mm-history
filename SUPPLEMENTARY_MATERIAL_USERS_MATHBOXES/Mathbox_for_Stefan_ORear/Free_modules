$(
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    Free modules
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
$)

  $c freeLMod unitVec $.

  $( Class of free module generator. $)
  cfrlm $a class freeLMod $.

  $( Class of basic unit vectors for an explicit free module. $)
  cuvc $a class unitVec $.

  ${
    $d r i j k $.

    $( The ` i ` -dimensional free module over a ring ` r ` is the product of
       ` i ` -many copies of the ring with componentwise addition and
       multiplication.  If ` i ` is infinite, the allowed vectors are
       restricted to those with finitely many nonzero cooerdinates; this
       ensures that the resulting module is actually spanned by its unit
       vectors. $)
    df-frlm $a |- freeLMod = ( r e. _V , i e. _V |->
        ( r (+)m ( i X. { ( ringLMod ` r ) } ) ) ) $.

    $( ` ( ( R unitVec I ) `` i ) ` is the unit vector in ` ( R freeLMod I ) `
       along the ` i ` axis. $)
    df-uvc $a |- unitVec = ( r e. _V , i e. _V |-> ( j e. i |->
        ( k e. i |-> if ( k = j , ( 1r ` r ) , ( 0g ` r ) ) ) ) ) $.
  $}

  $( value of free module $)
  $( demonstrate base set and operations for pedagogic value, including finite and infinite case, using oF and o. $)
  $( free module is spanned by basis vectors $)
  $( evaluation map from a free module to any other module: a map on basis extends (uniquely) to the whole $)
  $( use span preservation to show that the free module maps onto a span $)
  $( this allows for neat representation of spans: ellspd $)
  $( splitting theorem: free module on ( A u. B ) maps onto B with kernel A $)

  $(
  @{
    @d M a b c f @.  @d B a b c f @.  @d N a b c f @.  @d K a b c f @.
    @d S a b c f @.  @d Z a b c f @.  @d T a b c f @.  @d F a b c f @.
    @d I a b c f @.
    ellspd.n @e |- N = ( LSpan ` M ) @.
    ellspd.v @e |- B = ( Base ` M ) @.
    ellspd.k @e |- K = ( Base ` S ) @.
    ellspd.s @e |- S = ( Scalar ` M ) @.
    ellspd.z @e |- Z = ( 0g ` S ) @.
    ellspd.t @e |- T = ( vsca ` M ) @.

    @{
      ellspd.f @e |- ( ph -> F : I --> B ) @.
      ellspd.m @e |- ( ph -> M e. LMod ) @.
      ellspd.i @e |- ( ph -> I e. _V ) @.
      @( The elements of the span of an indexed collection of basic vectors are
         those vectors which can be written as finite linear combinations of
         basic vectors. @)
      ellspd @p |- ( ph -> ( X e. ( N ` ( F " I ) ) <->
          E. f e. ( K ^m I ) ( ( `' f " { Z } ) e. Fin /\
            X = ( M gsum ( f oF T F ) ) ) ) ) @=
        ? @.
    @}

    @{
      elfilspd.f @e |- ( ph -> F : I --> B ) @.
      elfilspd.m @e |- ( ph -> M e. LMod ) @.
      elfilspd.i @e |- ( ph -> I e. Fin ) @.
      @( Simplified version of ~ ellspd when the spanning set is finite: all
         linear combinations are then acceptable. @)
      elfilspd @p |- ( ph -> ( X e. ( N ` ( F " I ) ) <->
          E. f e. ( K ^m I ) X = ( M gsum ( f oF T F ) ) ) ) @=
        ? @.
    @}
  @}
  $)

