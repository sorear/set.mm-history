$(
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                   Generalized Multivariate Polynomials
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
$)

  $( Introduce new constant symbols. $)
  $c mPwSer $. $( Multivariate power series $)
  $c mVar $. $( Multivariate power series variables $)
  $c mPoly $. $( Multivariate polynomial $)
  $c evalSub $. $( Evaluation in a subring $)
  $c eval $. $( Evaluation of a multivariate polynomial $)
  $c selectVars $. $( Treat polynomial as a polynomial of polynomials $)
  $c mDeg $. $( Multivariate polynomial degree $)
  $c AlgInd $. $( Algebraically independent $)
  $c <bag $. $( Order on terms $)
  $c ordPwSer $. $( Order on power series $)

  $( Multivariate power series. $)
  cmps $a class mPwSer $.

  $( Multivariate power series variables. $)
  cmvr $a class mVar $.

  $( Multivariate polynomials. $)
  cmpl $a class mPoly $.

  $( Evaluation in a subring. $)
  ces $a class evalSub $.

  $( Evaluation of a multivariate polynomial. $)
  cevl $a class eval $.

  $( Select a subset of variables in a multivariate polynomial. $)
  cslv $a class selectVars $.

  $( Multivariate polynomial degree. $)
  cmdg $a class mDeg $.

  $( Algebraically independent. $)
  cai $a class AlgInd $.

  $( Ordering on terms of a multivariate polynomial. $)
  cltb $a class <bag $.

  $( Ordered set of power series. $)
  copws $a class ordPwSer $.

  ${
    $d b c d f g h i j k r s v w x y z $.
    $( Define the algebra of power series over the index set ` i ` and with
       coefficients from the ring ` r ` . $)
    df-psr $a |- mPwSer = ( i e. _V , r e. _V |->
    [_ { h e. ( NN0 ^m i ) | ( `' h " NN ) e. Fin } / d ]_ [_ ( r ^m d ) / b ]_
    ( { <. ( Base ` ndx ) , b >. ,
        <. ( +g ` ndx ) , ( oF ( +g ` r ) |` ( b x. b ) ) >. ,
        <. ( .r ` ndx ) ,
          ( f e. b , g e. b |-> ( k e. d |->
            prod_ x e. { y e. d | y oR <_ k } ( +g ` r )
            ( ( f ` x ) ( .r ` r ) ( g ` ( k oF - x ) ) ) ) ) >. } u.
      { <. ( Scalar ` ndx ) , r >. ,
        <. ( vsca ` ndx ) , ( x e. r , f e. b |->
             ( ( d X. { x } ) oF ( .r ` r ) f ) ) >. } ) ) $.

    $( Define the generating elements of the power series algebra. $)
    df-pbs $a |- mVar = ( i e. _V , r e. _V |-> ( x e. i |->
      ( f e. { h e. ( NN0 ^m i ) | ( h " NN ) e. Fin } |->
        if ( f = ( y e. i |-> if ( y = x , 1 , 0 ) ) ,
             ( 1r ` r ) , ( 0g ` r ) ) ) ) ) $.

    $( Define the subalgebra of the power series algebra generated by the
       variables; this is the polynomial algebra (the set of power series with
       finite degree). $)
    df-mpl $a |- mPoly = ( i e. _V , r e. _V |-> [_ ( i mPwSer r ) / w ]_
      ( w |`s ( ( AlgSpan ` w ) ` ran ( i mVar r ) ) ) ) $.

    $( Define the evaluation map for the polynomial algebra.  The function
       ` ( ( I evalSub S ) `` R ) : V --> ( S ^m ( S ^m I ) ) ` makes sense
       when ` I ` is an index set, ` S ` is a ring, ` R ` is a subring of
       ` S ` , and where ` V ` is the set of polynomials in
       ` ( I mPoly R ) ` .  This function maps an element of the formal
       polynomial algebra (with coefficients in ` R ` ) to a function from
       assignments ` I --> S ` of the variables to elements of ` S ` formed by
       evaluating the polynomial with the given assignments. $)
    df-evls $a |- evalSub = ( i e. _V , s e. _V |-> [_ ( Base ` s ) / b ]_
      ( r e. ~P b |-> [_ ( i mPoly ( s |`s r ) ) / w ]_ [_ ( Base ` w ) / v ]_
        ( iota_ f e. ( w RingHom ( s ^s ( b ^m i ) ) )
        A. x e. i ( f ` ( ( i mVar ( s |`s r ) ) ` x ) ) =
          ( g e. ( b ^m i ) |-> ( g ` x ) ) ) ) ) $.

    $( A simplication of ` evalSub ` when the evaluation ring is the same as
       the coefficient ring. $)
    df-evl $a |- eval = ( i e. _V , r e. _V |->
      ( ( i evalSub r ) ` ( Base ` r ) ) ) $.

    $( Define the "variable selection" function.  The function
       ` ( ( I selectVars R ) `` J ) ` maps elements of ` ( I mPoly R )
       ` bijectively onto ` ( J mPoly ( ( I \ J ) mPoly R ) )
       ` in the natural way, for example if ` I = { x , y } ` and ` J = { y }
       ` it would map ` 1 + x + y + x y e.  ( { x , y } mPoly ZZ ) ` to ` ( 1 +
       x ) + ( 1 + x ) y e.  ( { y } mPoly ( { x } mPoly ZZ ) )
` . This, for example, allows one to treat a multivariate polynomial as a univariate polynomial with coefficients in a polynomial ring with one less variable. $)
    df-selv $a |- selectVars = ( i e. _V , r e. _V |->
      ( j e. ~P i |-> ( f e. ( i mPoly r ) |->
      [_ ( ( i \ j ) mPoly r ) / s ]_ [_ ( const ` s ) / c ]_
        ( ( ( ( i evalSub s ) ` ( c "s r ) ) ` ( c o. f ) ) `
          ( x e. i |-> if ( x e. j , ( ( j mVar ( ( i \ j ) mPoly r ) ) ` x ) ,
            ( c o. ( ( ( i \ j ) mVar r ) ` x ) ) ) ) ) ) ) ) $.

    $( Define the degree of a polynomial. $)
    df-mdeg $a |- mDeg = ( i e. _V , r e. _V |-> ( f e. ( i mPoly r ) |->
      sup ( ran ( h e. ( `' f " ( _V \ { ( 0g ` r ) } ) ) |->
        sum_ x e. i ( h ` x ) ) , NN0 , < ) ) ) $.

    $( Define the predicate "the set ` v ` is algebraically independent in the
       algebra ` w ` ".  A collection of vectors is algebraically independent
       if no nontrivial polynomial with elements from the subset evaluates to
       zero. $)
    df-algind $a |- AlgInd = ( w e. _V , k e. ~P ( Base ` w ) |->
      { v e. ~P ( Base ` w ) | Fun `' ( f e. ( Base ` ( v mPoly ( w |`s k ) ) )
        |-> ( ( ( ( v evalSub w ) ` k ) ` f ) ` ( _I |` v ) ) ) } ) $.

    $( Define a well-order on the set of all finite bags from the index set
       ` i ` given a wellordering ` r ` of ` i ` . $)
    df-ltbag $a |- <bag = ( r e. _V , i e. _V |-> { <. f , g >. |
      ( { f , g } C_ { h e. ( NN0 ^m i ) | ( `' h " NN ) e. Fin } /\
        f =/= g /\ [ [_ { z e. i | ( f ` z ) =/= ( g ` z ) } / b ]_
           U. { x e. b | A. y e. b -. y r x } / j ]
        ( f ` j ) < ( g ` j ) ) } ) $.

    $( Define a total order on the set of all power series in ` s ` from the
       index set ` i ` given a wellordering ` r ` of ` i ` and a totally
       ordered base ring ` s ` . $)
    df-ordpsr $a |- ordPwSer = ( i e. _V , s e. _V |-> [_ ( Base ` s ) / b ]_
      ( r e. ~P ( i X. i ) |-> ( ( i mPwSer s ) sSet <. ( le ` ndx ) ,
       { <. f , g >. | ( { f , g } C_ ( Base ` ( i mPwSer s ) ) /\ ( f = g \/
        [ [_ { z e. dom f | ( f ` z ) =/= ( g ` z ) } / v ]_
           U. { x e. v | A. y e. v -. y ( r <bag i ) x } / j ]
        ( f ` j ) ( le ` s ) ( g ` j ) ) ) } >. ) ) ) $.
  $}

