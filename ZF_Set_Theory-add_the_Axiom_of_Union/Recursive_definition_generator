$(
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            Recursive definition generator
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
$)

  $( Define a constant for the recursive definition generator. $)
  $c rec $.

  $( Extend class notation with the recursive definition generator. $)
  crdg $a class rec ( A , B ) $.

  ${
    $d x y z f g F $.  $d x y z f g A $.
    $( Define a recursive definition generator on ` On ` (the class of ordinal
       numbers) with characteristic function ` F ` and initial value ` A ` .
       This combines functions ` F ` in ~ tfr1 and ` G ` in ~ tz7.44-1 into one
       definition.  This rather amazing operation allows us to define, with
       compact direct definitions, functions that are usually defined in
       textbooks only with indirect self-referencing recursive definitions.  A
       recursive definition requires advanced metalogic to justify - in
       particular, eliminating a recursive definition is very difficult and
       often not even shown in textbooks.  On the other hand, the elimination
       of a direct definition is a matter of simple mechanical substitution.
       The price paid is the daunting complexity of our ` rec ` operation.
       But once we get past this hurdle, otherwise recursive definitions become
       relatively simple, as in for example ~ oav , from which we prove
       the recursive textbook definition as theorems ~ oa0 , ~ oasuc , and
       ~ oalim (with the help of theorems ~ rdg0 , ~rdgsuc , and ~ rdglimi ).
       We can also restrict the ` rec ` operation to define otherwise recursive
       functions on the natural numbers ` om ` ; see ~ fr0g and ~ frsuc .
       Our ` rec ` operation apparently does not appear in published
       literature, although closely related is Definition 25.2 of [Quine]
       p. 177, which he uses to "turn...a recursion into a genuine or direct
       definition" (p. 174).  Note that the ` if ` operations (see ~ df-if )
       select cases based on whether the domain of ` g ` is zero, a successor,
       or a limit ordinal.

       An important use of this definition is in the recursive sequence
       generator ~ df-seq1 on the natural numbers (as a subset of the complex
       numbers), allowing us to define, with direct definitions, recursive
       infinite sequences such as the factorial function ~ df-fac and integer
       powers ~ df-exp .

       _Note: We introduce ` rec ` with the philosophical goal of being able_
       _to eliminate all definitions with direct mechanical substitution and_
       _to verify easily the soundness of definitions.  Metamath itself has no_
       _built-in technical limitation that prevents recursive definitions in_
       _the traditional textbook style_. $)
    df-rdg $a |- rec ( F , A ) = U. { f | E. x e. On ( f Fn x /\
                A. y e. x ( f ` y ) = ( { <. g , z >. | z = if ( g = (/) , A ,
                if ( Lim dom g , U. ran g , ( F ` ( g ` U. dom g ) ) ) ) }
                ` ( f |` y ) ) ) } $.
  $}

  ${
    $d x y z f g F $.  $d x y z f g A $.
    $( Alternate definition of a recursive definition generator.  (This was the
       original definition, but it was later replaced with the slightly shorter
       ~ df-rdg .) $)
    dfrdg2 $p |- rec ( F , A ) = U. { f | E. x e. On ( f Fn x /\
                A. y e. x ( f ` y ) = (
                    { <. g , z >. | ( ( g = (/) /\ z = A ) \/
                    ( -. ( g = (/) \/ Lim dom g ) /\
                        z = ( F ` ( g ` U. dom g ) ) )
                    \/ ( Lim dom g /\ z = U. ran g ) ) }
                ` ( f |` y ) ) ) } $=
      ( crdg cv wfn cfv cres c0 wceq cdm wlim crn cuni cif copab wral wa con0
      wrex cab wo wn w3o df-rdg eqif anbi2i orcom andi ioran anbi1i anass
      bitri dmeq dm0 syl6eq nlim0 limeq mtbiri syl con2i pm4.71ri orbi12i
      bitr4i 3bitri orbi2i 3orass 3bitr4i opabbii fveq1i eqeq2i ralbii rexbii
      abbii unieqi eqtri ) GDHEIZAIZJZBIZWAKZWAWDLZCIZFIZMNZDWHOZPZWHQRZWJRWHKG
      KZSZSNZFCTZKZNZBWBUAZUBZAUCUDZEUEZRWCWEWFWIWGDNUBZWIWKUFUGZWGWMNZUBZWKWGW
      LNZUBZUHZFCTZKZNZBWBUAZUBZAUCUDZEUEZRABCDEFGUIXBXPXAXOEWTXNAUCWSXMWCWRXLB
      WBWQXKWEWFWPXJWOXIFCXCWIUGZWGWNNZUBZUFXCXFXHUFZUFWOXIXSXTXCXSXQXHWKUGZXEU
      BZUFZUBXQYBXHUFZUBZXTXRYCXQWKWGWLWMUJUKYCYDXQXHYBULUKYEXQYBUBZXQXHUBZUFXT
      XQYBXHUMXFYFXHYGXFXQYAUBZXEUBYFXDYHXEWIWKUNUOXQYAXEUPUQXHXQWKUBZXGUBYGWKY
      IXGWKXQWIWKWIWJMNZYAWIWJMOMWHMURUSUTYJWKMPVAWJMVBVCVDVEVFUOXQWKXGUPUQVGVH
      VIVJWIWGDWNUJXCXFXHVKVLVMVNVOVPUKVQVRVSVT $.
      $( [16-Feb-2005] $) $( [15-Feb-2005] $)
  $}

  ${
    $d x y z f g F $.  $d x y z f g G $.  $d x y z f g A $.  $d x y z f g B $.
    $( Equality theorem for the recursive definition generator. $)
    rdgeq1 $p |- ( F = G -> rec ( F , A ) = rec ( G , A ) ) $=
      ( vf vx vy vz vg wceq cv wfn cfv cres c0 cdm wlim crn cuni cif copab
      wral wa con0 wrex cab crdg fveq1 ifeq2d eqeq2d opabbidv fveq1d ralbidv
      anbi2d rexbidv abbidv unieqd df-rdg 3eqtr4g ) BCIZDJZEJZKZFJZUTLZUTVCMZGJ
      ZHJZNIZAVGOZPZVGQRZVIRVGLZBLZSZSZIZHGTZLZIZFVAUAZUBZEUCUDZDUEZRVBVDVEVFVH
      AVJVKVLCLZSZSZIZHGTZLZIZFVAUAZUBZEUCUDZDUEZRBAUFCAUFUSWCWNUSWBWMDUSWAWLEU
      CUSVTWKVBUSVSWJFVAUSVRWIVDUSVEVQWHUSVPWGHGUSVOWFVFUSVHVNWEAUSVJVMWDVKVLBC
      UGUHUHUIUJUKUIULUMUNUOUPEFGADHBUQEFGADHCUQUR $.
      $( [9-Apr-1995] $)


    $( Equality theorem for the recursive definition generator. $)
    rdgeq2 $p |- ( A = B -> rec ( F , A ) = rec ( F , B ) ) $=
      ( vf vx vy vz vg wceq cv wfn cfv cres c0 cdm wlim crn cuni cif copab
      wral wa con0 wrex cab crdg ifeq1 eqeq2d opabbidv fveq1d ralbidv anbi2d
      rexbidv abbidv unieqd df-rdg 3eqtr4g ) ABIZDJZEJZKZFJZUSLZUSVBMZGJZHJZNIZ
      AVFOZPVFQRVHRVFLCLSZSZIZHGTZLZIZFUTUAZUBZEUCUDZDUEZRVAVCVDVEVGBVISZIZHGTZ
      LZIZFUTUAZUBZEUCUDZDUEZRCAUFCBUFURVRWGURVQWFDURVPWEEUCURVOWDVAURVNWCFUTUR
      VMWBVCURVDVLWAURVKVTHGURVJVSVEVGABVIUGUHUIUJUHUKULUMUNUOEFGADHCUPEFGBDHCU
      PUQ $.
      $( [9-Apr-1995] $)
  $}

  ${
    $d y z w v f g F $.  $d y z w v f g A $.  $d x y z w v f g $.
    hbrdg.1 $e |- ( y e. F -> A. x y e. F ) $.
    hbrdg.2 $e |- ( y e. A -> A. x y e. A ) $.
    $( Bound-variable hypothesis builder for the recursive definition
       generator. $)
    hbrdg $p |- ( y e. rec ( F , A ) -> A. x y e. rec ( F , A ) ) $=
      ( vf vw vv vz vg crdg cv wfn cfv cres c0 wceq cdm wlim crn cuni cif
      copab wral wa con0 wrex cab df-rdg wcel ax-17 hbfv hbif hbeq hbopab
      hbral hban hbrex hbab hbuni hbxfr ) ABDCLGMZHMZNZIMZVCOZVCVFPZJMZKMZQRZCV
      JSZTZVJUAUBZVLUBVJOZDOZUCZUCZRZKJUDZOZRZIVDUEZUFZHUGUHZGUIZUBHIJCGKDUJABW
      FWEAGBWDAHUGVDUGUKAULVEWCAVEAULWBAIVDVFVDUKAULABBVGWABMZVGUKAULABVHVTVSKJ
      ABABBVIVRWGVIUKAULVKABCVQVKAULFVMABVNVPVMAULWGVNUKAULABVODEWGVOUKAULUMUNU
      NUOUPWGVHUKAULUMUOUQURUSUTVAVB $.
      $( [14-Sep-2003] $)
  $}

  ${
    $d x y f g $.  $d x y z g $.  $d f g G $.  $d x z G $.  $d y z w g G $.
    $( Lemma used with the recursive definition generator.  This is a trivial
       lemma that just changes bound variables for later use. $)
    rdglem1 $p |- { f | E. x e. On ( f Fn x /\
                A. y e. x ( f ` y ) = ( G ` ( f |` y ) ) ) }
                = { g | E. z e. On ( g Fn z /\
                A. w e. z ( g ` w ) = ( G ` ( g |` w ) ) ) } $=
      ( cv wfn cfv cres wceq wral wa con0 wrex cab eqid tfrlem3 fveq2 reseq2
      fveq2d eqeq12d cbvralv anbi2i rexbii abbii eqtri ) EHZAHZIBHZUIJUIUKKGJLB
      UJMNAOPEQZFHZCHZIZUKUMJZUMUKKZGJZLZBUNMZNZCOPZFQUODHZUMJZUMVCKZGJZLZDUNMZ
      NZCOPZFQABCULEFGULRSVBVJFVAVICOUTVHUOUSVGBDUNUKVCLZUPVDURVFUKVCUMTVKUQVEG
      UKVCUMUAUBUCUDUEUFUGUH $.
      $( [7-May-2004] $) $( [9-Apr-1995] $)
  $}

  ${
    $d x y z w $.  $d x z w A $.  $d x z w H $.
    $( Lemma used with the recursive definition generator.  This is a trivial
       lemma that just changes bound variables for later use. $)
    rdglem2 $p |- { <. x , y >. | ( ( x = (/) /\ y = A ) \/
            ( -. ( x = (/) \/ Lim dom x ) /\ y = ( H ` ( x ` U. dom x ) ) )
                \/ ( Lim dom x /\ y = U. ran x ) ) }
                = { <. z , y >. | ( ( z = (/) /\ y = A ) \/
            ( -. ( z = (/) \/ Lim dom z ) /\ y = ( H ` ( z ` U. dom z ) ) )
                \/ ( Lim dom z /\ y = U. ran z ) ) } $=
      ( vw cv cop wceq c0 wa cdm wlim wo wn cuni cfv crn w3o wex cab copab
      opeq1 eqeq2d eqeq1 anbi1d wb dmeq limeq syl orbi12d notbid unieq fveq2
      3syl fveq1 eqtrd fveq2d anbi12d rneq unieqd 3orbi123d exbidv cbvexv
      abbii df-opab 3eqtr4i ) FGZAGZBGZHZIZVIJIZVJDIZKZVMVILZMZNZOZVJVPPZVIQZEQ
      ZIZKZVQVJVIRZPZIZKZSZKZBTZATZFUAVHCGZVJHZIZWMJIZVNKZWPWMLZMZNZOZVJWRPZWMQ
      ZEQZIZKZWSVJWMRZPZIZKZSZKZBTZCTZFUAWIABUBXKCBUBWLXNFWKXMACVIWMIZWJXLBXOVL
      WOWIXKXOVKWNVHVIWMVJUCUDXOVOWQWDXFWHXJXOVMWPVNVIWMJUEZUFXOVSXAWCXEXOVRWTX
      OVMWPVQWSXPXOVPWRIZVQWSUGVIWMUHZVPWRUIUJZUKULXOWBXDVJXOWAXCEXOWAXBVIQZXCX
      OXQVTXBIWAXTIXRVPWRUMVTXBVIUNUOXBVIWMUPUQURUDUSXOVQWSWGXIXSXOWFXHVJXOWEXG
      VIWMUTVAUDUSVBUSVCVDVEWIABFVFXKCBFVFVG $.
      $( [9-Apr-1995] $)
  $}

  ${
    $d x y z f g u v w F $.  $d x y z f g u v w A $.
    $( The recursive definition generator is a function on ordinal numbers. $)
    rdgfnon $p |- rec ( F , A ) Fn On $=
      ( vx vy vw vu vv vz vg vf cv wfn cfv cres c0 wceq cdm wlim crn cuni cif
      copab wral wa con0 wrex cab crdg rdglem1 df-rdg tfr1 ) CDEKZFKZLGKZULMULU
      NNHKIKZOPAUOQZRUOSTUPTUOMBMUAUAPIHUBZMPGUMUCUDFUEUFEUGJBAUHUQFGCDEJUQUIFG
      HAEIBUJUK $.
      $( [9-Apr-1995] $)
  $}

  ${
    $d x y z f g u v w F $.  $d x y z f g u v w A $.
    $( Value of the recursive definition generator. $)
    rdgval $p |- ( g e. On -> ( rec ( F , A ) ` g ) = (
                       { <. w , z >. | ( ( w = (/) /\ z = A ) \/
                       ( -. ( w = (/) \/ Lim dom w ) /\
                               z = ( F ` ( w ` U. dom w ) ) )
                       \/ ( Lim dom w /\ z = U. ran w ) ) }
                   ` ( rec ( F , A ) |` g ) ) ) $=
      ( vx vy vu vv vf cv con0 wcel crdg cfv cres c0 wceq wa cdm wlim wo wn
      cuni crn w3o copab wfn wral wrex cab rdglem1 dfrdg2 tfr2 rdglem2 fveq1i
      syl6eq ) DKZLMURECNZOUSURPZURQRZAKZCRZSVAURTZUAZUBUCVBVDUDUROEORSVEVBURUE
      UDRSUFDAUGZOUTBKZQRZVCSVHVGTZUAZUBUCVBVIUDVGOEORSVJVBVGUEUDRSUFBAUGZOFGDV
      GHKZUHIKZVGOVGVMPVFORIVLUISHLUJBUKJUSVFHIFGBJVFULHIACBDEUMUNUTVFVKDABCEUO
      UPUQ $.
      $( [9-Apr-1995] $)
  $}

  ${
    $d z g w F $.  $d z g w A $.
    ${
      rdg.1 $e |- A e. V $.
      $( The initial value of the recursive definition generator. $)
      rdg0 $p |- ( rec ( F , A ) ` (/) ) = A $=
        ( vg vz vw crdg cv c0 wceq wa cdm wlim wo wn cuni cfv crn w3o copab
        rdglem2 rdgfnon rdgval tz7.44-1 ) DEABAGFHZIJZEHZAJKUFUELZMZNOUGUHPUEQB
        QJKUIUGUERPJKSFETBFEDABUAABUBEFADBUCCUD $.
        $( [23-Apr-1995] $)
    $}

    ${
      $d z g B $.
      rdg.2 $e |- B e. On $.
      $( The value of the recursive definition generator at a successor. $)
      rdgsuci $p |- ( rec ( F , A ) ` suc B )
                   = ( F ` ( rec ( F , A ) ` B ) ) $=
        ( vg vz vw crdg cv c0 wceq wa cdm wlim wo wn cuni cfv crn w3o copab
        rdglem2 rdgfnon rdgval tz7.44-2 ) EFABCAHGIZJKZFIZAKLUGUFMZNZOPUHUIQUFR
        CRKLUJUHUFSQKLTGFUACGFEACUBACUCFGAECUDDUE $.
        $( [23-Apr-1995] $)

      $( The value of the recursive definition generator at a limit ordinal. $)
      rdglimi $p |- ( Lim B ->
                   ( rec ( F , A ) ` B ) = U. ( rec ( F , A ) " B ) ) $=
        ( vg vz vw crdg cv c0 wceq wa cdm wlim wo wn cuni cfv crn w3o copab
        rdglem2 rdgfnon rdgval tz7.44-3 ) EFABCAHGIZJKZFIZAKLUGUFMZNZOPUHUIQUFR
        CRKLUJUHUFSQKLTGFUACGFEACUBACUCFGAECUDDUE $.
        $( [23-Apr-1995] $)
    $}
  $}

  ${
    $d x A $.  $d x F $.
    $( The initial value of the recursive definition generator. $)
    rdg0g $p |- ( A e. C -> ( rec ( F , A ) ` (/) ) = A ) $=
      ( vx c0 cv crdg cfv wceq rdgeq2 fveq1d id eqeq12d visset rdg0 vtoclg ) EC
      DFZGZHZQIECAGZHZAIDABQAIZSUAQAUBERTQACJKUBLMQCDNOP $.
      $( [25-Apr-1995] $)
  $}

  $( The value of the recursive definition generator at a successor. $)
  rdgsuc $p |- ( B e. On ->
               ( rec ( F , A ) ` suc B ) = ( F ` ( rec ( F , A ) ` B ) ) ) $=
    ( con0 wcel csuc crdg cfv wceq c0 cif suceq fveq2d fveq2 eqeq12d 0elon
    elimel rdgsuci dedth ) BDEZBFZCAGZHZBUBHZCHZITBJKZFZUBHZUFUBHZCHZIBJBUFIZUC
    UHUEUJUKUAUGUBBUFLMUKUDUICBUFUBNMOAUFCBJDPQRS $.
    $( [23-Apr-1995] $)

  ${
    $d z D $.  $d y z C $.  $d z A $.  $d z B $.  $d x y z $.
    rdgsucopab.1 $e |- ( z e. A -> A. x z e. A ) $.
    rdgsucopab.2 $e |- ( z e. B -> A. x z e. B ) $.
    rdgsucopab.3 $e |- ( z e. D -> A. x z e. D ) $.
    rdgsucopab.4 $e |- F = rec ( { <. x , y >. | y = C } , A ) $.
    rdgsucopab.5 $e |- ( x = ( F ` B ) -> C = D ) $.
    $( The value of the recursive definition generator at a successor (special
       case where the characteristic function is an ordered pair
       abstraction). $)
    rdgsucopab $p |- ( ( B e. On /\ D e. R ) ->  ( F ` suc B ) = D ) $=
      ( con0 wcel csuc cfv cv wceq copab crdg rdgsuc fveq1i syl5eq cvv fvex
      hbopab1 hbrdg hbfv eqeq2i sylbir fvopabgf mpan sylan9eq ) EOPZGHPZEQZIRZE
      BSFTZABUAZDUBZRZVARZGUPURVBRVDUSDEVAUCURIVBMUDUEVCUFPUQVDGTEVBUGABCVCFGUF
      HACEVBACDVAUTABCUHJUIKUJLASZVCTVEEIRZTFGTVFVCVEEIVBMUDUKNULUMUNUO $.
      $( [30-Oct-2003] $) $( [22-Oct-2003] $)

    $( The value of the recursive definition generator at a successor (special
       case where the characteristic function is an ordered-pair class
       abstraction and where the mapping class ` D ` is a proper class).  This
       is a technical lemma that can be used together with ~ rdgsucopab to help
       eliminate redundant sethood antecedents. $)
    rdgsucopabn $p |- ( -. D e. V ->  ( F ` suc B ) = (/) ) $=
      ( con0 wcel cvv wn csuc cfv c0 wceq wi cv copab crdg rdgsuc fveq1i
      syl5eq hbopab1 hbrdg hbfv eqeq2i sylbir fvopabnf sylan9eq ex cdm sucelon
      dmeqi wfn rdgfnon fndm ax-mp eqtri eleq2i bitr4i notbii ndmfv sylbi a1d
      pm2.61i ) ENOZGPOQZERZHSZTUAZUBVLVMVPVLVMVOEBUCFUAZABUDZDUEZSZVRSZTVLVNVS
      SWAVODEVRUFVNHVSLUGUHABCVTFGACEVSACDVRVQABCUIIUJJUKKAUCZVTUAWBEHSZUAFGUAW
      CVTWBEHVSLUGULMUMUNUOUPVLQZVPVMWDVNHUQZOZQVPVLWFVLVNNOWFEURWENVNWEVSUQZNH
      VSLUSVSNUTWGNUADVRVANVSVBVCVDVEVFVGVNHVHVIVJVK $.
      $( [8-Nov-2003] $) $( [22-Oct-2003] $)
  $}

  $( The value of the recursive definition generator at a limit ordinal. $)
  rdglim $p |- ( ( B e. C /\ Lim B ) ->
                 ( rec ( F , A ) ` B ) = U. ( rec ( F , A ) " B ) ) $=
    ( wcel wlim con0 crdg cfv cima cuni wceq limelon wi c0 cif limeq fveq2
    imaeq2 unieqd eqeq12d imbi12d 0elon elimel rdglimi dedth imp sylancom ) BCE
    BFZBGEZBDAHZIZUKBJZKZLZBCMUJUIUOUJUIUONUJBOPZFZUPUKIZUKUPJZKZLZNBOBUPLZUIUQ
    UOVABUPQVBULURUNUTBUPUKRVBUMUSBUPUKSTUAUBAUPDBOGUCUDUEUFUGUH $.
    $( [23-Apr-1995] $)

  ${
    $d x y A $.  $d x y B $.  $d x y F $.
    $( The value of the recursive definition generator at a limit ordinal,
       in terms of the union of all smaller values. $)
    rdglim2 $p |- ( ( B e. C /\ Lim B ) -> ( rec ( F , A ) ` B ) =
                  U. { y | E. x e. B y = ( rec ( F , A ) ` x ) } ) $=
      ( wcel wlim wa crdg cfv cima cuni cv wceq wrex cab rdglim cop wex con0
      wb word wi limord ordelord ex visset elon syl6ibr syl wfn rdgfnon
      fnopfvb mpan eqcom syl5bb syl6 pm5.32d exbidv df-rex syl5rbb abbidv
      dfima3 syl5eq unieqd adantl eqtrd ) DEGZDHZIDFCJZKVKDLZMZBNZANZVKKZOZADPZ
      BQZMZCDEFRVJVMVTOVIVJVLVSVJVODGZVOVNSVKGZIZATZBQVSVLVJWDVRBVJWAVQIZATWDVR
      VJWEWCAVJWAVQWBVJWAVOUAGZVQWBUBVJDUCZWAWFUDDUEWGWAVOUCZWFWGWAWHDVOUFUGVOA
      UHUIUJUKWFVPVNOZWBVQVKUAULWFWIWBUBCFUMUAVOVNVKBUHUNUOVNVPUPUQURUSUTVQADVA
      VBVCABVKDVDVEVFVGVH $.
      $( [23-Apr-1995] $)

    $( The value of the recursive definition generator at a limit ordinal,
       in terms of indexed union of all smaller values. $)
    rdglim2a $p |- ( ( B e. C /\ Lim B ) -> ( rec ( F , A ) ` B ) =
                  U_ x e. B ( rec ( F , A ) ` x ) ) $=
      ( vy wcel wlim wa crdg cfv cv wceq wrex cab cuni ciun rdglim2 fvex
      dfiun2 syl6eqr ) CDGCHICEBJZKFLALZUBKZMACNFOPACUDQAFBCDERAFCUDUCUBSTUA $.
      $( [28-Jun-1998] $)
  $}

