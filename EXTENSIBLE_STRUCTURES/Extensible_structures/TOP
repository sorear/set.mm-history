$(
#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
                    Extensible structures
#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
$)


  ${
    $d t E $.  $d t S $.  $d s t N $.
    strfvn.f $e |- S e. _V $.
    strfvn.c $e |- E = ( s e. _V |-> ( s ` N ) ) $.
    $( Value of a structure component extractor ` E ` .  Normally, ` E ` is a
       defined constant symbol such as ` Base ` ( ~ df-base ) and ` N ` is a
       fixed integer such as ` 1 ` . ` S ` is a structure, i.e. a specific
       member of a class of structures such as ` Poset ` ( ~ df-poset ) where
       ` S e. Poset ` .

       Note:  Normally, this theorem shouldn't be used outside of this section,
       because it requires hard-coded index values.  Instead, use ~ strfv .

       _General remarks_:  An "extensible structure" is a function (set of
       ordered pairs) on a finite (and not necessarily sequential) subset of
       ` NN ` , used to define a specific group, ring, poset, etc.  The
       function's argument is the index of a structure component (such as ` 1 `
       for the base set of a group), and its value is the component (such as
       the base set).  A group will have at least two components (base set and
       operation), although it can be further specialized by adding other
       components such as a multiplicative operation for rings (and still
       remain a group per our definition).  Thus every ring is also a group.
       This allows theorems from more general structures (groups) to be reused
       for more specialized structures (rings) without having to reprove
       them. $)
    strfvn $p |- ( E ` S ) = ( S ` N ) $=
      ( vt cv cfv wceq fveq2 fveq1 eqeq12d cvv wcel vex fvex fvmpt ax-mp vtocl
      ) GHZBIZCUAIZJZABIZCAIZJGAEUAAJUBUEUCUFUAABKCUAALMUANOUDGPDUACDHZIUCNBCUG
      UALFCUAQRST $.
      $( [6-Oct-2013] $) $( [9-Sep-2011] $)
  $}

  $c ndx $.
  $c sSet $.

  $( Extend class notation with the structure component index extractor. $)
  cnx $a class ndx $.

  $( Set components of a structure. $)
  csts $a class sSet $.

  $( Define the structure component index extractor.  See theorem ~ ndxarg to
     understand its purpose.  The restriction to ` NN ` allows ` ndx ` to exist
     as a set, since ` _I ` is a proper class.  In principle, we could have
     chosen ` CC ` or (if we revise all structure component definitions such as
     ~ df-base ) another set such as the natural ordinal numbers ` om `
     ( ~ df-om ). $)
  df-ndx $a |- ndx = ( _I |` NN ) $.

  ${
    $d e s $.
    $( Set one or more components of a structure. $)
    df-sets $a |- sSet = ( s e. _V , e e. _V |->
      ( ( s |` ( _V \ dom e ) ) u. e ) ) $.
  $}

  ${
    $d s N $.
    ndxarg.1 $e |- E = ( s e. _V |-> ( s ` N ) ) $.
    ndxarg.2 $e |- N e. NN $.
    $( Get the numeric argument from a defined structure component extractor
       such as ~ df-base . $)
    ndxarg $p |- ( E ` ndx ) = N $=
      ( cnx cfv cid cn cres cvv df-ndx wcel resiexg ax-mp eqeltri strfvn fveq1i
      nnex wceq fvresi 3eqtri ) FAGBFGBHIJZGZBFABCFUCKLIKMUCKMSIKNOPDQBFUCLRBIM
      UDBTEIBUAOUB $.
      $( [6-Oct-2013] $)

    $( A structure component extractor is defined by its own index.  This
       theorem, together with ~ strfv below, is useful for avoiding direct
       reference to the hard-coded numeric index in component extractor
       definitions, such as the ` 1 ` in ~ df-base and the ` 10 ` in ~ df-ple ,
       making it easier to change should the need arise.  For example, we can
       refer to a specific poset with base set ` B ` and order relation ` L `
       using ` { <. ( Base `` ndx ) , B >. , <. ( le `` ndx ) , L >. } ` rather
       than ` { <. 1 , B >. , <. 10 , L >. } ` .  The latter, while shorter to
       state, requires revision if we later change ` 10 ` to some other number,
       and it may also be harder to remember. $)
    ndxid $p |- E = ( s e. _V |-> ( s ` ( E ` ndx ) ) ) $=
      ( cvv cv cfv cmpt cnx ndxarg fveq2i mpteq2i eqtr4i ) ACFBCGZHZICFJAHZOHZI
      DCFRPQBOABCDEKLMN $.
      $( [6-Oct-2013] $) $( [19-Oct-2012] $)
  $}

  ${
    $d e s E $.  $d e s S $.
    setsval.1 $e |- E e. _V $.
    $( Value of the structure replacement function.  (Contributed by Mario
       Carneiro, 1-Dec-2014.) $)
    setsval $p |- ( S e. V -> ( S sSet E ) =
      ( ( S |` ( _V \ dom E ) ) u. E ) ) $=
      ( vs ve wcel cvv cdm cdif cres cun csts co wceq elex resexg unexg sylancl
      cv reseq1 dmeq difeq2d reseq2 syl sylan9eq simpr uneq12d df-sets ovmpt2ga
      wa mp3an2 syl2anc ) ACGZAHGZAHBIZJZKZBLZHGZABMNUSOZACPUNURHGBHGZUTAUQCQDU
      RBHHRSUOVBUTVADEFABHHETZHFTZIZJZKZVDLUSMHVCAOZVDBOZUKVGURVDBVHVIVGAVFKZUR
      VCAVFUAVIVFUQOVJUROVIVEUPHVDBUBUCVFUQAUDUEUFVHVIUGUHFEUIUJULUM $.
      $( [1-Dec-2014] $)
  $}

  ${
    $d s E $.
    strfv.s $e |- S e. _V $.
    strfv.f $e |- Fun S $.
    strfv.e $e |- E = ( s e. _V |-> ( s ` ( E ` ndx ) ) ) $.
    strfv.n $e |- <. ( E ` ndx ) , C >. e. S $.
    $( Extract a structure component ` C ` (such as the base set) from a
       structure ` S ` (such as a member of ` Poset ` , ~ df-poset ) with a
       component extractor ` E ` (such as the base set extractor ~ df-base ).
       By virtue of ~ ndxid , this can be done without having to refer to the
       hard-coded numeric index of ` E ` . $)
    strfv $p |- ( C e. V -> C = ( E ` S ) ) $=
      ( wcel cfv cnx strfvn cop wceq wfun wi funopfvg mpan2 mpi syl5req ) ADJZB
      CKLCKZBKZABCUCEFHMUBUCANBJZUDAOZIUBBPUEUFQGUCADBRSTUA $.
      $( [6-Oct-2013] $)

    $d s S $.  $d s W $.
    $( Value of the structure replacement function at a replaced index.
       (Contributed by Mario Carneiro, 1-Dec-2014.) $)
    setsid $p |- ( ( W e. A /\ C e. V ) -> C = ( E ` ( W sSet S ) ) ) $=
      ( wcel cfv wceq cnx cvv cres cun c0 ax-mp wa csts co strfv adantl setsval
      cdm cdif fveq2d resexg unexg sylancl cv fveq1 fvex fvmpt syl eqtrd strfvn
      resundir resres incom disjdif eqtri reseq2i res0 3eqtri wrel funrel resdm
      cin wfun uneq12i uncom un0 fveq1i cop opeldm fvres 3eqtr2i syl6eqr adantr
      eqtr4d ) FALZBELZUABCDMZFCUBUCZDMZWEBWFNWDBCDEGHIJKUDUEWDWHWFNWEWDWHODMZF
      PCUGZUHZQZCRZMZWFWDWHWMDMZWNWDWGWMDFCAHUFUIWDWMPLZWOWNNWDWLPLCPLWPFWKAUJH
      WLCPPUKULGWMWIGUMZMWNPDWIWQWMUNJWIWMUOUPUQURWFWICMWIWMWJQZMZWNCDWIGHJUSWI
      WRCWRWLWJQZCWJQZRSCRZCWLCWJUTWTSXACWTFWKWJVKZQFSQSFWKWJVAXCSFXCWJWKVKSWKW
      JVBWJPVCVDVEFVFVGCVHZXACNCVLXDICVITCVJTVMXBCSRCSCVNCVOVDVGVPWIWJLZWSWNNWI
      BVQCLXEKWIBCODUOVRTWIWJWMVSTVTWAWBWC $.
      $( [1-Dec-2014] $)
  $}

  ${
    $d s E $.  $d s S $.  $d s W $.
    setsnid.s $e |- S e. _V $.
    setsnid.d $e |- dom S = D $.
    setsnid.e $e |- E = ( s e. _V |-> ( s ` ( E ` ndx ) ) ) $.
    setsnid.n $e |- -. ( E ` ndx ) e. D $.
    $( Value of the structure replacement function at an untouched index.
       (Contributed by Mario Carneiro, 1-Dec-2014.) $)
    setsnid $p |- ( W e. V -> ( E ` W ) = ( E ` ( W sSet S ) ) ) $=
      ( wcel cfv cnx cvv wceq fvex cres cun c0 ax-mp csts co cv fveq1 fvmpt syl
      elex cdm cdif setsval fveq1d resundir residm cin dmres incom disjdif wrel
      3eqtri wb relres reldm0 mpbir uneq12i fveq1i wn mpbir2an difeq2i eleqtrri
      un0 eldif fvres 3eqtr3i syl6eq eqtr4d ovex syl6eqr ) EDKZECLZMCLZEBUAUBZL
      ZWACLZVRVSVTELZWBVRENKVSWDOEDUGFEVTFUCZLZWDNCVTWEEUDIVTEPUEUFVRWBVTENBUHZ
      UIZQZBRZLZWDVRVTWAWJEBDGUJUKVTWJWHQZLZVTWILZWKWDVTWLWIWLWIWHQZBWHQZRWISRW
      IWIBWHULWOWIWPSEWHUMWPSOZWPUHZSOZWRWHWGUNWGWHUNSBWHUOWHWGUPWGNUQUSWPURWQW
      SUTBWHVAWPVBTVCVDWIVJUSVEVTWHKZWMWKOVTNAUIZWHVTXAKVTNKVTAKVFVTNAVKMCPJVGW
      GANHVHVIZVTWHWJVLTWTWNWDOXBVTWHEVLTVMVNVOWANKWCWBOEBUAVPFWAWFWBNCVTWEWAUD
      IVTWAPUETVQ $.
      $( [1-Dec-2014] $)
  $}

  ${
    $d s E $.
    strss.t $e |- T e. _V $.
    strss.f $e |- Fun T $.
    strss.s $e |- S C_ T $.
    strss.e $e |- E = ( s e. _V |-> ( s ` ( E ` ndx ) ) ) $.
    strss.n $e |- <. ( E ` ndx ) , C >. e. S $.
    $( Propagate component extraction to a structure ` T ` from a subset
       structure ` S ` . $)
    strss $p |- ( E ` T ) = ( E ` S ) $=
      ( cvv wcel cnx cfv cif wceq cop opeq2d strfv wfun elimel iftrue wn opprc2
      fvex iffalse eqtr4d pm2.61i eqeltri sselii ssexi wss funss eqtr3d ax-mp
      mp2 ) AKLZAMDNZOZKLZCDNZBDNZPAURKMDUEUAUTUSVAVBUSCDKEFGIBCURUSQZHVCURAQZB
      UQVCVDPUQUSAURUQAURUBRUQUCZVCURURQVDVEUSURURUQAURUFRURAUDUGUHJUIZUJSUSBDK
      EBCFHUKBCULCTBTHGBCUMUPIVFSUNUO $.
      $( [15-Jan-2014] $) $( [11-Oct-2013] $)
  $}

  ${
    str0.a $e |- F = ( s e. _V |-> ( s ` I ) ) $.
    $( All components of the empty set are empty sets.  (Contributed by Stefan
       O'Rear, 27-Nov-2014.) $)
    str0 $p |- ( F ` (/) ) = (/) $=
      ( c0 cvv wcel cfv wceq 0ex cv fveq1 fv01 syl6eq fvmpt ax-mp ) EFGEAHEIJCE
      BCKZHZEFAQEIRBEHEBQELBMNDJOP $.
      $( [27-Nov-2014] $)
  $}

