$(
#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
                    Extensible structures
#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
$)


  ${
    $d t E $.  $d t S $.  $d s t N $.
    strfvn.f $e |- S e. _V $.
    strfvn.c $e |- E = ( s e. _V |-> ( s ` N ) ) $.
    $( Value of a structure component extractor ` E ` .  Normally, ` E ` is a
       defined constant symbol such as ` Base ` ( ~ df-base ) and ` N ` is a
       fixed integer such as ` 1 ` . ` S ` is a structure, i.e. a specific
       member of a class of structures such as ` Poset ` ( ~ df-poset ) where
       ` S e. Poset ` .

       Note:  Normally, this theorem shouldn't be used outside of this section,
       because it requires hard-coded index values.  Instead, use ~ strfv .

       _General remarks_:  An "extensible structure" is a function (set of
       ordered pairs) on a finite (and not necessarily sequential) subset of
       ` NN ` , used to define a specific group, ring, poset, etc.  The
       function's argument is the index of a structure component (such as ` 1 `
       for the base set of a group), and its value is the component (such as
       the base set).  A group will have at least two components (base set and
       operation), although it can be further specialized by adding other
       components such as a multiplicative operation for rings (and still
       remain a group per our definition).  Thus every ring is also a group.
       This allows theorems from more general structures (groups) to be reused
       for more specialized structures (rings) without having to reprove
       them. $)
    strfvn $p |- ( E ` S ) = ( S ` N ) $=
      ( vt cv cfv wceq fveq2 fveq1 eqeq12d cvv wcel vex fvex fvmpt ax-mp vtocl
      ) GHZBIZCUAIZJZABIZCAIZJGAEUAAJUBUEUCUFUAABKCUAALMUANOUDGPDUACDHZIUCNBCUG
      UALFCUAQRST $.
      $( [6-Oct-2013] $) $( [9-Sep-2011] $)
  $}

  $c ndx $.

  $( Extend class notation with the structure component index extractor. $)
  cnx $a class ndx $.

  $( Define the structure component index extractor.  See theorem ~ ndxarg to
     understand its purpose.  The restriction to ` NN ` allows ` ndx ` to exist
     as a set, since ` _I ` is a proper class.  In principle, we could have
     chosen ` CC ` or (if we revise all structure component definitions such as
     ~ df-base ) another set such as the natural ordinal numbers ` om `
     ( ~ df-om ). $)
  df-ndx $a |- ndx = ( _I |` NN ) $.

  ${
    $d s N $.
    ndxarg.1 $e |- E = ( s e. _V |-> ( s ` N ) ) $.
    ndxarg.2 $e |- N e. NN $.
    $( Get the numeric argument from a defined structure component extractor
       such as ~ df-base . $)
    ndxarg $p |- ( E ` ndx ) = N $=
      ( cnx cfv cid cn cres cvv df-ndx wcel resiexg ax-mp eqeltri strfvn fveq1i
      nnex wceq fvresi 3eqtri ) FAGBFGBHIJZGZBFABCFUCKLIKMUCKMSIKNOPDQBFUCLRBIM
      UDBTEIBUAOUB $.
      $( [6-Oct-2013] $)

    $( A structure component extractor is defined by its own index.  This
       theorem, together with ~ strfv below, is useful for avoiding direct
       reference to the hard-coded numeric index in component extractor
       definitions, such as the ` 1 ` in ~ df-base and the ` 10 ` in ~ df-ple ,
       making it easier to change should the need arise.  For example, we can
       refer to a specific poset with base set ` B ` and order relation ` L `
       using ` { <. ( Base `` ndx ) , B >. , <. ( le `` ndx ) , L >. } ` rather
       than ` { <. 1 , B >. , <. 10 , L >. } ` .  The latter, while shorter to
       state, requires revision if we later change ` 10 ` to some other number,
       and it may also be harder to remember. $)
    ndxid $p |- E = ( s e. _V |-> ( s ` ( E ` ndx ) ) ) $=
      ( cvv cv cfv cmpt cnx ndxarg fveq2i mpteq2i eqtr4i ) ACFBCGZHZICFJAHZOHZI
      DCFRPQBOABCDEKLMN $.
      $( [6-Oct-2013] $) $( [19-Oct-2012] $)
  $}

  ${
    $d s E $.
    strfv.s $e |- S e. _V $.
    strfv.f $e |- Fun S $.
    strfv.e $e |- E = ( s e. _V |-> ( s ` ( E ` ndx ) ) ) $.
    strfv.n $e |- <. ( E ` ndx ) , C >. e. S $.
    $( Extract a structure component ` C ` (such as the base set) from a
       structure ` S ` (such as a member of ` Poset ` , ~ df-poset ) with a
       component extractor ` E ` (such as the base set extractor ~ df-base ).
       By virtue of ~ ndxid , this can be done without having to refer to the
       hard-coded numeric index of ` E ` . $)
    strfv $p |- ( C e. V -> C = ( E ` S ) ) $=
      ( wcel cfv cnx strfvn cop wceq wfun wi funopfvg mpan2 mpi syl5req ) ADJZB
      CKLCKZBKZABCUCEFHMUBUCANBJZUDAOZIUBBPUEUFQGUCADBRSTUA $.
      $( [6-Oct-2013] $)
  $}

  ${
    $d s E $.
    strss.t $e |- T e. _V $.
    strss.f $e |- Fun T $.
    strss.s $e |- S C_ T $.
    strss.e $e |- E = ( s e. _V |-> ( s ` ( E ` ndx ) ) ) $.
    strss.n $e |- <. ( E ` ndx ) , C >. e. S $.
    $( Propagate component extraction to a structure ` T ` from a subset
       structure ` S ` . $)
    strss $p |- ( E ` T ) = ( E ` S ) $=
      ( cvv wcel cnx cfv cif wceq cop opeq2d strfv wfun elimel iftrue wn opprc2
      fvex iffalse eqtr4d pm2.61i eqeltri sselii ssexi wss funss eqtr3d ax-mp
      mp2 ) AKLZAMDNZOZKLZCDNZBDNZPAURKMDUEUAUTUSVAVBUSCDKEFGIBCURUSQZHVCURAQZB
      UQVCVDPUQUSAURUQAURUBRUQUCZVCURURQVDVEUSURURUQAURUFRURAUDUGUHJUIZUJSUSBDK
      EBCFHUKBCULCTBTHGBCUMUPIVFSUNUO $.
      $( [15-Jan-2014] $) $( [11-Oct-2013] $)
  $}


