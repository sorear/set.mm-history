$(
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
           The axioms for the equality predicate (except ax-11)
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
$)

$(
$)

  $( Declare the equality predicate symbol. $)
  $c = $.  $( Equal sign (read:  'is equal to') $)

  $( --- Start of patch to prevent connective overloading $)
  $c class $.
  $( (The purpose of introducing ` class x ` here, and not in set theory where
     it belongs, is to allow us to express i.e. "prove" the ~ weq of predicate
     calculus from the ~ wceq of set theory, so that we don't "overload" the
     ` = ` connective with two syntax definitions.  This is done to prevent
     ambiguity that causes problems in some Metamath parsers.  The remaining
     part of this description applies to set theory, not predicate calculus.)

     This syntax construction states that a variable ` x ` , which has been
     declared to be a set variable by $f statement vx, is also a class
     expression.  This can be justified informally as follows.  We know that
     the class builder ` { y | y e. x } ` is a class by ~ cab .  Since (when
     ` y ` is distinct from ` x ` ) we have ` x = { y | y e. x } ` by
     ~ cvjust , we can argue that that the syntax " ` class x ` " can be
     viewed as an abbreviation for " ` class { y | y e. x } ` ".  See the
     discussion under the definition of class in [Jech] p. 4 showing that
     "Every set can be considered to be a class."

     While it is tempting and perhaps occasionally useful to view ~ cv as a
     "type conversion" from a set variable to a class variable, keep in mind
     that ~ cv is intrinsically no different from any other class-building
     syntax such as ~ cab , ~ cun , or ~ c0 . $)
  cv $a class x $.

  ${
    $v A $.
    $v B $.
    wceq.cA $f class A $.
    wceq.cB $f class B $.
    $( (The purpose of introducing ` wff A = B ` here, and not in set theory
       where it belongs, is to allow us to express i.e. "prove" the ~ weq of
       predicate calculus in terms of the ~ wceq of set theory, so that we
       don't "overload" the ` = ` connective with two syntax definitions.
       This is done to prevent ambiguity that causes problems in some Metamath
       parsers.  For example, some parsers - although not the Metamath
       program - stumble on the fact that the ` = ` in ` x = y ` could be the
       ` = ` of either ~ weq or ~ wceq , although mathematically it makes no
       difference.  The class variables ` A ` and ` B ` are introduced
       temporarily for the purpose of this definition but otherwise not used
       in predicate calculus.  See ~ df-cleq for more information on the set
       theory usage of ~ wceq .)

       Extend wff definition to include class equality. $)
    wceq $a wff A = B $.
  $}

  $( (Instead of introducing ~ weq as an axiomatic statement, as was done
     in an older version of this database, we introduce it by "proving" a
     special case of set theory's more general ~ wceq .  This lets us avoid
     overloading the ` = ` connective, thus preventing ambiguity that causes
     problems in certain Metamath parsers.  However, logically ~ weq is
     considered to be a primitive syntax, even though here it is artificially
     "derived" from ~ wceq .  Note: To see the proof steps of this syntax
     proof, type "show proof weq /all" in the Metamath program.)

     Extend wff definition to include atomic formulas using the equality
     predicate. $)
  weq $p wff x = y $=
    ( cv wceq ) ACBCD $.
    $( [24-Jan-2006] $)
  $( --- End of patch to prevent connective overloading $)

  $( --- Start of old code before overloading prevention patch. $)
  $(
  @( Extend wff definition to include atomic formulas using the equality
     predicate.

     After we introduce ~ cv and ~ wceq in set theory, this syntax construction
     becomes redundant, since it can be derived with the proof
     "vx cv vy cv wceq". @)
  weq @a wff x = y @.
  $)
  $( --- End of old code before overloading prevention patch. $)

  $( Axiom of Equality.  One of the equality and substitution axioms of
     predicate calculus with equality.  This is similar to, but not quite, a
     transitive law for equality (proved later as ~ equtr ).  Axiom scheme C8'
     in [Megill] p. 448  (p. 16 of the preprint).  Also appears as Axiom C7 of
     [Monk2] p. 105.

     Axioms ~ ax-8 through ~ ax-16 are the axioms having to do with
     equality, substitution, and logical properties of our binary predicate
     ` e. ` (which later in set theory will mean "is a member of").  Note
     that all axioms except ~ ax-16 and ~ ax-17 are still valid even when
     ` x ` , ` y ` , and ` z ` are replaced with the same variable because they
     do not have any distinct variable (Metamath's $d) restrictions.  Distinct
     variable restrictions are required for ~ ax-16 and ~ ax-17 only. $)
  ax-8 $a |- ( x = y -> ( x = z -> y = z ) ) $.

  $( Axiom of Existence.  One of the equality and substitution axioms of
     predicate calculus with equality.  This axiom in effect tells us that at
     least one thing exists.  In this form (not requiring that ` x ` and ` y `
     be distinct) it was used in an axiom system of Tarski (see Axiom B7' in
     footnote 1 of [KalishMontague] p. 81.)  It is equivalent to axiom scheme
     C10' in [Megill] p. 448 (p. 16 of the preprint); the equivalence is
     established by ~ ax9 and ~ ax9a .  A more convenient form of this axiom
     is ~ a9e , which has additional remarks.

     Raph Levien proved the independence of this axiom from the others on
     12-Apr-2005.  See item 16 at
     ~ http://us.metamath.org/award2003.html . $)
  ax-9 $a |- -. A. x -. x = y $.

  $( Axiom of Quantifier Substitution.  One of the equality and substitution
     axioms of predicate calculus with equality.  Axiom scheme C11' in [Megill]
     p. 448 (p. 16 of the preprint).  It apparently does not otherwise appear
     in the literature but is easily proved from textbook predicate calculus by
     cases.  This is a technical axiom wherein the antecedent is ordinarily
     true only if ` x ` and ` y ` are the same variable, and in that case it
     doesn't matter which one you use in a quantifier.  (Strictly speaking, the
     antecedent is also true when ` x ` and ` y ` are different variables in
     the case of a one-element domain of discourse, but then the consequent is
     also true in a one-element domain.  For compatibility with traditional
     predicate calculus all our predicate calculus axioms hold in a one-element
     domain, but this becomes unimportant in set theory where we show in ~ dtru
     that at least 2 things exist.)  $)
  ax-10 $a |- ( A. x x = y -> ( A. x ph -> A. y ph ) ) $.

  $( Axiom of Quantifier Introduction.  One of the equality and substitution
     axioms of predicate calculus with equality.  Informally, it says that
     whenever ` z ` is distinct from ` x ` and ` y ` , and ` x = y ` is true,
     then ` x = y ` quantified with ` z ` is also true.  In other words, ` z `
     is irrelevant to the truth of ` x = y ` .  Axiom scheme C9' in [Megill]
     p. 448  (p. 16 of the preprint).  It apparently does not otherwise appear
     in the literature but is easily proved from textbook predicate calculus
     by cases.

     An open problem is whether this axiom is redundant.  Note that the
     analogous axiom for the membership connective, ~ ax-15 , has been shown
     to be redundant. $)
  ax-12 $a |- ( -. A. z z = x -> ( -. A. z z = y ->
              ( x = y -> A. z x = y ) ) ) $.

